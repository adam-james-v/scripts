* scripts
#+Title: scripts
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: excl
#+PROPERTY: header-args :cache yes :noweb yes :results none :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** readme
The readme
#+begin_src markdown :tangle ./readme.md
# adam-james-scripts

A collection of scripts. Primarily built with Clojure/babashka, but may use other methods occasionally.

This is a long-term, slow moving project, perhaps only ever useful to me. But I like the idea of keeping some utility scripts nicely organized in this repo.

Notes can be found in the [scripts.org](https://github.com/adam-james-v/scripts/blob/main/scripts.org) file at the top level of this project.

Everything's free to use and modify.

## Usage
I use scripter.clj and uberscripter.clj to 'build' my src scripts. 

```
bb uberscripter.clj src/some-script.clj
```

You can also open scripts.org in emacs and use cider-connect to build/use script code interactively.

In a terminal, in the project's top level launch an nrepl with babashka

```
bb --nrepl-server
```

Then, in emacs using CIDER, you can connet to the REPL. The below example has the default host/port.

```
M-x cider-connect RET
localhost RET
1667 RET
```

You can use other REPL/emacs plugin combinations. The [babashka book](https://book.babashka.org/) is a good place to start when looking for setup instructions and ideas.

Once you're connected, you can load any script and get hacking! If I want to mess around with the 'vidwiz' script, I would eval the following in the REPL to load the code and enter the ns:

```clojure
(load-file "src/vidwiz.clj")

(ns vidwiz.main
  "This is a prototype script for automating a portion of my video editing using ffmpeg."
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [hiccup.core :refer [html]]
            [svg-clj.main :as svg]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]))
```

Just be aware of any scripts with side-effects!

## Scripter/Uberscripter

Uberscripter uses babashka's --uberscript option to create a single-file script. It looks at the file's deps and copies code into the file.

Scripter is much simpler and just copies a src script into build and makes it executable. This is useful for situations where a script doesn't work nicely with uberscript, for example, if your script uses clojure.spec.

The build folder is on my PATH env variable, so as soon as a script is moved and made executable, it becomes available from anywhere. You will need to start a new terminal session or refresh your current one to see this take effect.

## Contribution

Feel free to fork, clone, make PRs, whatever.

Changes will be implemented at my discretion, because these are scripts tuned to my needs/workflow anyway.

You can create issues to bring up improvements, questions, and ideas as well, if you'd like. 

Be kind and constructive.

#+end_src

* uberscripter
Run this from the top level of the scripts folder to create an uberscript in the build folder.

Example:

bb uberscripter src/clj-to-scad.clj

creates the file build/clj-to-scad.uber.clj

Uberscripter assumes that the first line in the script is the shebang line. Then, it assumes that the second form will be in the form:

#+begin_src clojure
(babashka.deps/add-deps '{:deps your-deps-map})
#+end_src

It's a naive approach, but if you have that initial format for your script, uberscripter will properly find deps and build a classpath.

#+begin_src clojure :tangle ./uberscripter.clj
(ns uberscripter.core
  (:require [babashka.classpath :refer [add-classpath]]
            [clojure.string :as st]
            [clojure.java.shell :refer [sh]]))

(defn get-deps
  [f]
  (->> (slurp f)
       (format "[%s]")
       read-string
       first
       second
       second
       str
       (sh "clojure" "-Spath" "-Sdeps")
       :out
       st/trim))

(defn remove-deps
  [f]
  (->> (slurp f)
       (format "[%s]")
       read-string
       rest
       (interpose "\n\n")
       (apply str)))

(defn split-fname
  [fname]
  (let [sf (st/split fname #"\.")]
    [(apply str (drop-last sf))
     (last sf)]))

(defn split-folders
  [name]
  (let [sf (st/split name #"/")]
    (vec sf)))

(defn build
  [f]
  (let [[name ext] (split-fname f)
        sname (split-folders name)
        xfname (if (= (first sname) "src")
                 (apply str (conj (rest sname) "build/"))
                 (apply str (interpose "/" sname)))
        fout (str xfname ".uber." ext)
        ftemp (str f ".tmp")]
    (spit ftemp (remove-deps f))
    (sh "bb" "--classpath" (get-deps f)
        "-f" ftemp "--uberscript" fout)
    (sh "rm" ftemp)
    (->> (slurp fout)
         (str "#!/usr/bin/env bb\n\n")
         (spit fout))
    (println fout)
    (sh "chmod" "+x" fout)))

(defn main
  []
  (let [f (first *command-line-args*)]
    (println (str "Building script: " f))
    (build f)
    #_(println (get-deps f))))

(main)
#+end_src
* scripter
Run this from the top level of the scripts folder to create a standard script in the build folder.

Example:

bb scripter src/clj-to-scad.clj

creates the file build/clj-to-scad.clj

This is meant to be used for projects that have trouble being built with the uberscripter.

#+begin_src clojure :tangle ./scripter.clj
(ns scripter.core
  (:require [babashka.classpath :refer [add-classpath]]
            [clojure.string :as st]
            [clojure.java.shell :refer [sh]]))

(defn split-fname
  [fname]
  (let [sf (st/split fname #"\.")]
    [(apply str (drop-last sf))
     (last sf)]))

(defn split-folders
  [name]
  (let [sf (st/split name #"/")]
    (vec sf)))

(defn move
  [f]
  (let [[name ext] (split-fname f)
        sname (split-folders name)
        xfname (if (= (first sname) "src")
                 (apply str (conj (rest sname) "build/"))
                 (apply str (interpose "/" sname)))
        fout (str xfname "." ext)]
    (println fout)
    (sh "chmod" "+x" fout)))

(defn main
  []
  (let [f (first *command-line-args*)]
    (println (str "Moving script: " f))
    (move f)
    #_(println (get-deps f))))

(main)
#+end_src
* clj->scad
Builds .clj files using the scad-clj library. Result is a compiled .scad file.

The script does not require any programs to be installed, though you may want to have OpenSCAD to be able to see the result.

This could be useful in a file-watcher pipeline.

** deps
#+begin_src clojure :tangle ./src/clj-to-scad.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   #_{scad-clj/scad-clj {:mvn/version "0.5.3"}}
   {scad-clj/scad-clj {:local/root "/Users/adam/dev/scad-clj"}}})

#+end_src

** ns
#+begin_src clojure :tangle ./src/clj-to-scad.clj
(ns clj-to-scad.main
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [clojure.data.xml :as xml]
            [svg-clj.path :as path]
            [svg-clj.utils :as utils]
            [svg-clj.transforms :as tf]
            [scad-clj.model :refer :all]
            [scad-clj.scad :refer [write-scad]]))

#+end_src

** utils
#+begin_src clojure :tangle ./src/clj-to-scad.clj
(defn clj-file->scad-block
  [fname]
  (let [[name ext] (str/split fname #"\.")]
    (if (= ext "scad")
      (slurp fname)
      (->> (slurp fname)
           (format "[%s]")
           load-string
           (filter (complement var?))))))
#+end_src

** animation
Chromakey works decently well, but requires you to make a custom 'greenscreen' color scheme file in OpenSCAD. background color is changed to #00FF00 so that chroma is easy to do. This won't work if you don't have the greenscreen json file in your OpenSCAD's install folder.

You can manually change the colorscheme + chromakey color to use a built-in scheme and things should work OK.

#+begin_src clojure :tangle ./src/clj-to-scad.clj
(defn png!
  [fname scad-block]
  (let [scad (write-scad [(fn! 150) scad-block])]
    (sh "openscad" "/dev/stdin"
        "--imgsize" "600,600"
        "--projection" "orthogonal"
        "--colorscheme" "greenscreen"
        "--camera" "0,0,0,55,0,25,2200"
        "-o" fname
        :in scad)))

(defn- anim-frames! [f name framerate dur]
  (let [mkdir (sh "mkdir" "-pv" name)
        frames (int (* framerate dur))
        framefn (fn [fr] (png! 
                          (format (str name "/%03d.png") fr)
                          (f (/ fr frames))))]
    (when (= 0 (:exit mkdir))
      (into [] (map framefn (range 1 (inc frames)))))))

(defn- anim-video! [name framerate]
  (let [ffmpeg 
        (sh "ffmpeg" "-f" "image2" "-r" (str framerate)
            "-i" (str name "/%03d.png")
            "-c:v" "libvpx-vp9"
            "-vf" "chromakey=0x00FF00:0.25:0.1"
            "-y" (str name ".webm"))]
    (when (= 0 (:exit ffmpeg))
      (sh "rm" "-rf" name))))

(defn animate! [{:keys [graphics-fn name framerate duration]}]
  (do (anim-frames! graphics-fn name framerate duration)
      (anim-video! name framerate)))

#+end_src

** img->scad
#+begin_src clojure :tangle ./src/clj-to-scad.clj
(defn img->str [fname]
  "Ingest image file `fname` and transform it into a hiccup data structure."
  (let [new-fname (str (first (str/split fname #"\.")) ".svg")]
    (sh "vtracer" 
        "--mode" "polygon"
        "--colormode" "bw"
        "--input" fname
        "--output" new-fname)
    (let [svg-str (slurp new-fname)]
      (sh "rm" new-fname)
      (-> svg-str
          (str/replace #"<\?xml.+>" "")
          str/trim))))

;; xml parse/transform technique is from:
;; https://github.com/babashka/babashka/blob/master/examples/portal.clj

(defn xml->hiccup [xml]
  (if-let [t (:tag xml)]
    (let [elt [t]
          elt (if-let [attrs (:attrs xml)]
                (conj elt attrs)
                elt)]
      (into elt (map xml->hiccup (:content xml))))
    xml))

(defn str->elements
  [str]
  (-> str
      (xml/parse-str :namespace-aware false
                     :skip-whitespace true)
      xml->hiccup
      (->> (drop 2))))

(defn split-path
  [[k props]]
  (let [ps (-> (:d props)
               (str/split #"(?=M)")
               (->> (map str/trim)))]
    (map #(assoc-in [k props] [1 :d] %) ps)))

(defn path->pts
  [path-elem]
  (let [cmds (path/path-string->commands (get-in path-elem [1 :d]))]
    (mapv :input cmds)))

#_(-> "drawing.png"
      img->str
      str->elements 
      (->> (mapcat split-path)))

(defn re-center
  [seq]
  (let [group (svg-clj.main/g seq)
        ctr (mapv float (tf/centroid group))]
    (->> seq
         (map #(tf/translate (utils/v* [-1 -1] ctr) %)))))

#+end_src

** primitives
#+begin_src clojure :tangle ./src/clj-to-scad.clj
(defn line
  [from to]
  (let [r 0.7]
    (color [0 0 0 1]
           (if (= from to)
             (sphere r)
             (let [diff (map - to from)
                   norm (utils/distance from to)
                   rotate-angle (Math/acos (/ (last diff) norm))
                   rotate-axis [(- (nth diff 1)) (nth diff 0) 0]]
               (union
                (sphere r)
                (translate to (sphere r))
                (->> (cylinder r norm)
                     (translate [0 0 (/ norm 2)])
                     (rotate rotate-angle rotate-axis)
                     (translate from))))))))

(defn polyline
  [pts]
  (apply union (map #(apply line %) (partition 2 1 pts))))

(defn- add-z
  [pts]
  (map #(conj % 0) pts))

(defn line-drawing
  [fname]
  (-> fname
      img->str
      str->elements
      re-center
      (->> (mapcat split-path))
      (->> (map path->pts))
      (->> (map add-z))
      (->> (map polyline))
      union))

(defn- flip-y
  [pts]
  (map #(utils/v* % [1 -1]) pts))

(defn svg-path-elem->scad-polygon
  [path-elem]
  (-> path-elem
      split-path
      (->> (map path->pts))
      (->> (map flip-y))
      (->> (map polygon))
      (->> (apply difference))))

(defn drawing
  [fname]
  (-> fname
      img->str
      str->elements
      #_re-center
      (->> (map svg-path-elem->scad-polygon))
      union))

(defn linecube
  [x y z]
  (union
   (color [0 1 0 1] (cube x y z))
   (translate [(/ x -2.0) (/ y -2.0) (/ z -2.0)]
    (union
     (line [0 0 0] [x 0 0])
     (line [x 0 0] [x y 0])
     (line [x y 0] [0 y 0])
     (line [0 y 0] [0 0 0])
     (line [0 0 0] [0 0 z])
     (line [x 0 0] [x 0 z])
     (line [x y 0] [x y z])
     (line [0 y 0] [0 y z])
     (line [0 0 z] [x 0 z])
     (line [x 0 z] [x y z])
     (line [x y z] [0 y z])
     (line [0 y z] [0 0 z])))))

(def cube-anim
  {:name "cube"
   :framerate 30
   :duration 4
   :graphics-fn
   (fn [t]
     (rotate [0 0 (* t (deg->rad 360))] (linecube 70 70 70)))})

(def draw-anim
  {:name "drawing"
   :framerate 30
   :duration 4
   :graphics-fn
   (fn [t]
     (rotate [0 0 (* t (deg->rad 360))]
             (->> (drawing "drawing2.png")
                  (rotate [(deg->rad 90) 0 0]))))})

(def vase-anim
  {:name "vase"
   :framerate 120
   :duration 4
   :graphics-fn
   (fn [t]
     (->> (drawing "drawing4.png")
          (extrude-rotate {:angle (* t 360)})
          (translate [0 0 300])))})

#+end_src

** cli
To be improved. I want a mechanism to allow the user to make animations and/or clj->scad files quickly and easily.

#+begin_src clojure :tangle ./src/clj-to-scad.clj
(defn build
  [fname]
  (let [fout (-> fname (str/split #"\.") first (str ".scad"))]
    (->> (slurp fname)
         (format "[%s]")
         load-string
         (filter (complement var?))
         write-scad
         (spit fout))))

#_(build (first *command-line-args*))

#+end_src

* clj->step
Builds .clj files into .step files using freecad. Prototype status.

Some notes from Grazfather:

use the <() to make pseudo files this is the 'process substitution' operator

eg. 
echo <(echo hello)
cat <(echo hello)

diff <(xxd bin1) <(xxd bin2)

I can use the above to clean up the python script/freecad invocation. basically eliminating the need to spit fcscript.py to disk.

This script requires my local scad-clj fork (sorry). That's because it needs to emit csg, not scad (an undocumented subset of scad language).

It also requires an installation of freecad, so it's a heavy project for the time being.

** deps
#+begin_src clojure :tangle ./src/clj-to-step.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {scad-clj/scad-clj {:local/root "/Users/adam/dev/scad-clj"}}})
#+end_src

** main
#+begin_src clojure :tangle ./src/clj-to-step.clj
(ns clj-to-step.main
  (:require [clojure.string :as st]
            [clojure.java.shell :refer [sh]]
            [scad-clj.model :refer :all]
            [scad-clj.csg :refer [write-csg]]))

(def this-directory (->> (sh "pwd")
                         :out
                         st/trim))

(defn exporter-script [ipath opath]
  (str "
import FreeCAD
import importCSG
import Import

App.newDocument(\"a\")
doc = FreeCAD.getDocument(\"a\")
importCSG.insert(u\"" ipath "\", \"a\")
__objs__ = doc.RootObjects
Import.export(__objs__, u\"" opath "\")
del __objs__"))

(defn scad->step
  [f scad-block]
  (let [path this-directory]
    (->> scad-block
         write-csg
         (spit "scadout.csg"))
    (->> (str path "/" f)
         (exporter-script (str path "/scadout.csg"))
         (spit "fcscript.py"))
    (sh "freecad" "fcscript.py")
    (sh "rm" "-rf" 
        "fcscript.py"
        "parsetab.py"
        "scadout.csg"
        "__pycache__")))

(defn build
  [f]
  (let [fout (-> f (st/split #"\.") first (str ".step"))]
    (->> f
         slurp
         (format "[%s]")
         load-string
         (filter (complement var?))
         (scad->step fout))))

#_(println this-directory)
(build (first *command-line-args*))
#+end_src
* clj->svg
Builds .clj files using the scad-clj library. Result is a compiled .scad file.

** deps
#+begin_src clojure :tangle ./src/clj-to-svg.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {borkdude/spartan.spec {:git/url "https://github.com/borkdude/spartan.spec"
                               :sha "e5c9f40ebcc64b27b3e3e83ad2a285ccc0997097"}
    svg-clj/svg-clj {:git/url "https://github.com/adam-james-v/svg-clj"
                     :sha "aaf78937d7a59e11aa7b193c2f9da35d9d159ca6"}}
   :classpath-overrides {org.clojure/clojure nil
                         org.clojure/spec.alpha nil
                         org.clojure/core.specs.alpha nil}})
#+end_src

** main
#+begin_src clojure :tangle ./src/clj-to-svg.clj
(ns clj-to-svg.main
  (:require [spartan.spec :as s]
            [clojure.string :as st]
            [svg-clj.main :refer :all]
            [hiccup.core :refer [html]]))
(require '[spartan.spec])
(alias 's 'clojure.spec.alpha)

;; suggestion from Michiel @borkdude on stream
(require '[clojure.spec.alpha :as s])

(defn build
  [f]
  (let [fout (-> f (st/split #"\.") first (str ".svg"))]
    (->> (slurp f)
         (format "[%s]")
         load-string
         (filter (complement var?))
         html
         (spit fout))))

(build (first *command-line-args*))
#+end_src
* slice-anim
This doesn't work yet.

** deps
#+begin_src clojure tangle ./src/scad-slice.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {svg-clj/scad-clj {:local/root "/Users/adam/dev/scad-clj"}
    svg-clj/svg-clj {:local/root "/Users/adam/dev/svg-clj"}
    borkdude/spartan.spec {:git/url "https://github.com/borkdude/spartan.spec"
                               :sha "e5c9f40ebcc64b27b3e3e83ad2a285ccc0997097"}}})
#+end_src

** main
#+begin_src clojure tangle ./src/scad-slice.clj
(ns scad-slice.main
  (:require [spartan.spec]
            [clojure.spec.alpha :as s]
            [scad-clj.model :refer :all]
            [scad-clj.scad :refer [write-scad]]
            [svg-clj.main :as svg]
            [hiccup.core :refer [html]]
            [clojure.string :as st]
            [clojure.java.shell :refer [sh]]))

(defn f->path
  [f]
  (->> (slurp f)
       st/split-lines
       (drop 2)
       (apply str)
       svg/->edn
       svg/unwrap-elements))

(defn to-deg
  [rad]
  (* rad (/ 180 Math/PI)))

(defn to-rad
  [deg]
  (* deg (/ Math/PI 180)))

(defn round
  [num places]
  (let [d (Math/pow 10 places)]
    (/ (Math/round (* num d)) d)))

(defn sin-cos-pair [theta]
  [(Math/sin (to-rad theta)) (Math/cos (to-rad theta))])

(defn rot-pt-2d
  [[x y] theta]
  (let [[s-t c-t] (sin-cos-pair theta)]
    [(- (* x c-t) (* y s-t))
     (+ (* y c-t) (* x s-t))]))

;; this rotates a point around [0,0,0]
(defn rot-pt
  [[x y z] axis theta]
  (cond
    (= axis :x) (into [x] (rot-pt-2d [y z] theta))
    (= axis :y) (apply #(into [] [%2 y %1]) (rot-pt-2d [z x] theta))
    (= axis :z) (into (rot-pt-2d [x y] theta) [z])))

(defn rotate-point
  [pt [ax ay az]]
  (-> pt
      (rot-pt :z az)
      (rot-pt :y ay)
      (rot-pt :x ax)))

(defn rotate-points
  [pts [ax ay az]]
  (mapv #(rotate-point % [ax ay az]) pts))

(def iso-euler-angles [35.264 45 0])
(def origin-angle-adjust-a [90 0 0])
(def origin-angle-adjust-b [0 -90 0])

(defn isometric-xf
  [pts]
  (-> pts
      (rotate-points origin-angle-adjust-a)
      (rotate-points origin-angle-adjust-b)
      (rotate-points iso-euler-angles)))

(defn top-xf
  [pts]
  (-> pts
      (rotate-points [0 0 0])))

(defn right-xf
  [pts]
  (-> pts
      (rotate-points [90 0 0])))

(defn add-z [pt2d] (vec (concat pt2d [0])))
(defn drop-z [pt3d] (vec (take 2 pt3d)))
(defn round-pt [places pt] (mapv #(round % places) pt))

(defn path->path-pts
  [path]
  (->> (get-in path [1 :d])
       svg/path-string->commands
       (partition-by #(= "Z" (:command %)))
       (partition 2)
       (map vec)
       (map #(apply concat %))
       (map #(map :input %))
       (mapv #(vec (filter (complement nil?) %)))))

(defn re-zero
  [path]
  (let [[[minx miny] _ _ _] (svg/bounds path)]
    (svg/translate [(- minx) (- miny)] path)))

(defn bb-dims
  [path]
  (let [[[minx miny] _ [maxx maxy] _] (svg/bounds path)]
    [(int (Math/ceil (- maxx minx)))
     (int (Math/ceil (- maxy miny)))]))

(defn pts-bb-area
  [pts]
  (->> pts
       svg/polygon-path
       bb-dims
       (apply *)))

(defn remove-largest
  [n path]
  (let [ctr (svg/centroid path)
        rem (->> path
                 path->path-pts
                 (sort-by pts-bb-area)
                 (drop-last n))]
    (if (< 0 (count rem))
      (->> rem
           (map svg/polygon-path)
           (apply svg/merge-paths)
           vec)
      (svg/polygon-path [ ctr ]))))

(defn path->iso-path
  [path]
  (->> path
       path->path-pts
       (map #(mapv add-z %))
       (map isometric-xf)
       (map #(mapv drop-z %))
       (map #(mapv (partial round-pt 5) %))
       (map svg/polygon-path)
       (apply svg/merge-paths)
       vec
       re-zero
       (remove-largest 2)
       (svg/style {:fill "none"
                   :stroke "slategray"
                   :stroke-width "0.5px"})))

(defn vstack
  [gap elems]
  (let [elems (vec elems)]
    (->>
     (apply svg/g
            (for [y (reverse (range (count elems)))]
              (svg/translate [0 (* y gap)]
                             (get elems (- (dec (count elems)) y)))))
     re-zero)))

(defn slices->svg
  [gap slices]
  (->> slices
       (map path->iso-path)
       (vstack gap)
       (#(svg/svg (concat (bb-dims %) [1]) %))
       html
       (spit "iso-slices.svg")))

(defn scad->slice-anim
  [scad-block]
  (let [st 5]
    (pmap
      (fn [a]
        (do
         (->> scad-block
              (union (difference
                      (cube 1000 1000 1000)
                      (cube 999 999 1100)))
              (translate [0 0 (- a)])
              (scale [25.4 25.4 25.4])
              cut
              write-scad
              (spit (format "slice/%03d.scad" (int (/ a st)))))
         (sh "openscad" (format "slice/%03d.scad" (int (/ a st)))
             "-o" (format "slice/%03d.svg" (int (/ a st))))))
      (range 0 110 st))
    #_(->> (range 0 (int (/ 110 5)))
         (map #(format "slice/%03d.svg" %))
         (map f->path)
         (map first)
         (slices->svg st))))

(defn merge-slice-files
  []
  (->> (range 0 (int (/ 110 5)))
       (map #(format "slice/%03d.svg" %))
       (map f->path)
       (map first)
       (slices->svg 5)))

(defn clj->slice-anim
  [f]
  (->> f
       slurp
       (format "[%s]")
       load-string
       (filter (complement var?))
       scad->slice-anim)
  merge-slice-files)

(defn elem?
  [elem]
  (or (s/valid? :svg-clj.main/basic-element elem)
      (s/valid? :svg-clj.main/text-element elem)
      (s/valid? :svg-clj.main/g-element elem)
      (s/valid? :svg-clj.main/path-element elem)))

#_(clj->slice-anim (first *command-line-args*))
#_(merge-slice-files)
#+end_src

#+begin_src clojure :tangle ./src/scad-slice.clj
(->> "slice/006.svg"
     f->path
     first
     (#(get-in % [1 :d]))
     (s/explain :svg-clj.main/path-string)
     println)
#+end_src
* png->svg
Traces a png image and approximates it with an SVG path.

This script requires vtracer to be installed and available on your PATH.

[vtracer](https://github.com/visioncortex/vtracer)

** deps
#+begin_src clojure :tangle ./src/png-to-svg.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {borkdude/spartan.spec {:git/url "https://github.com/borkdude/spartan.spec"
                           :sha "e5c9f40ebcc64b27b3e3e83ad2a285ccc0997097"}
    org.clojure/math.combinatorics {:mvn/version "0.1.6"}
    svg-clj/svg-clj {:local/root "/Users/adam/dev/svg-clj"}}})

#+end_src

** ns
#+begin_src clojure :tangle ./src/png-to-svg.clj
(ns png-to-svg.main
  (:require [clojure.string :as str]
            [clojure.math.combinatorics :as combo]
            [clojure.java.shell :refer [sh]]
            [clojure.data.xml :as xml]
            [svg-clj.main :refer :all]
            [svg-clj.path :as path]
            [svg-clj.utils :as utils]
            [svg-clj.transforms :as tf]
            [hiccup.core :refer [html]]))

#+end_src

** img->edn
#+begin_src clojure :tangle ./src/png-to-svg.clj
(defn img->str [fname]
  "Ingest image file `fname` and transform it into a hiccup data structure."
  (let [new-fname (str (first (st/split fname #"\.")) ".svg")]
    (sh "vtracer" 
        "--mode" "polygon"
        "--colormode" "bw"
        "--input" fname
        "--output" new-fname)
    (let [svg-str (slurp new-fname)]
      (sh "rm" new-fname)
      (-> svg-str
          (str/replace #"<\?xml.+>" "")
          str/trim))))

;; xml parse/transform technique is from:
;; https://github.com/babashka/babashka/blob/master/examples/portal.clj

(defn xml->hiccup [xml]
  (if-let [t (:tag xml)]
    (let [elt [t]
          elt (if-let [attrs (:attrs xml)]
                (conj elt attrs)
                elt)]
      (into elt (map xml->hiccup (:content xml))))
    xml))

(defn str->elements
  [str]
  (-> str
      (xml/parse-str :namespace-aware false
                     :skip-whitespace true)
      xml->hiccup
      (->> (drop 2))))

(defn split-path
  [[k props]]
  (let [ps (-> (:d props)
               (str/split #"(?=M)")
               (->> (map str/trim)))]
    (map #(assoc-in [k props] [1 :d] %) ps)))

(defn path->pts
  [path-elem]
  (let [cmds (path/path-string->commands (get-in path-elem [1 :d]))]
    (mapv :input cmds)))

#_(-> "drawing.png"
      img->str
      str->elements 
      (->> (mapcat split-path)))

(defn re-center
  [seq]
  (let [group (g seq)
        ctr (mapv float (tf/centroid group))]
    (->> seq
         (map #(tf/translate (utils/v* [-1 -1] ctr) %)))))

#+end_src

** main
#+begin_src clojure :tangle ./src/png-to-svg.clj
(defn build
  [f]
  (let [fout (-> f (st/split #"\.") first (str ".svg"))]
    (->> f
         img->str
         str->elements
         re-center
         #_(svg [2048 2048 1]))))

(build (first *command-line-args*))
#+end_src
* vidwiz
** ns
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {borkdude/spartan.spec {:git/url "https://github.com/borkdude/spartan.spec"
                               :sha "e5c9f40ebcc64b27b3e3e83ad2a285ccc0997097"}
    svg-clj/svg-clj {:local/root "/Users/adam/dev/svg-clj"}}})

(ns vidwiz.main
  "This is a prototype script for automating a portion of my video editing using ffmpeg."
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]
            [hiccup.core :refer [html]]
            [cheshire.core :refer [parse-string]]
            [svg-clj.main :as svg]
            [svg-clj.path :as path]
            [svg-clj.transforms :as tf]))

#+END_SRC

** utility
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
;; utils
(defn get-extension
  [fname]
  (re-find #"\.[A-Za-z\d+]+" fname))

(defn get-resolution-old
  [fname]
  (->> (sh "ffprobe" "-i" fname)
       :err
       (re-find #"\d\d+x\d+")
       (#(str/split % #"x"))
       (mapv read-string)))

(defn get-resolution
  [fname]
  (when-let [{:keys [width height]}
             (-> (sh "ffprobe"
                     "-v"
                     "error"
                     "-select_streams"
                     "v:0"
                     "-show_entries"
                     "stream=width,height"
                     "-of" "json"
                     fname)
                 :out
                 (parse-string true)
                 :streams
                 first)]
    [width height]))

(defn get-duration
  [fname]
  (when-let [{:keys [duration]}
             (-> (sh "ffprobe"
                     "-v"
                     "error"
                     "-select_streams"
                     "v:0"
                     "-show_entries"
                     "stream=duration"
                     "-of" "json"
                     fname)
                 :out
                 (parse-string true)
                 :streams
                 first)]
    (read-string duration)))

(defn overlay-offsets
  [{:keys [border base-dims overlay-dims pos gap fname]}]
  (let [{:keys [width]} border
        [cw ch] (map #(+ (* 2 width) %) overlay-dims)
        {:keys [h v]} pos
        [sw sh] base-dims]
    [(cond (= h :l) gap
           (= h :c) (- (/ sw 2) (/ cw 2))
           (= h :r) (- sw gap cw))
     (cond (= v :t) gap
           (= v :c) (- (/ sh 2) (/ ch 2))
           (= v :b) (- sh gap ch))]))

(defn get-bg-color
  [fname]
  (let [nfname (str/replace fname (get-extension fname) ".png")]
    (sh "ffmpeg" "-i" fname
        "-frames:v" "1"
        "-filter_complex"
        (str "[0:v]crop=4:4:100:500")
        "-y" (str nfname))
    (sh "convert" nfname "-colors" "1" nfname)
    (let [col (->> (sh "identify" "-verbose" nfname)
                   :out
                   (str/split-lines)
                   (drop-while #(not (str/includes? % "Histogram")))
                   (second)
                   (re-find #"\#......"))]
      (sh "rm" nfname)
      col)))

(defn seconds->timestamp [s]
  (let [hh (format "%02d" (int (/ s 3600)))
        mm (format "%02d" (int (/ (rem s 3600) 60)))
        ss (format "%02d" (rem s 60))]
    (apply str (interpose ":" [hh mm ss]))))

(defn clean-name [name]
  (-> name
      (str/lower-case)
      (str/replace #"!" "")
      (str/replace #"'" "")
      (str/replace #"," "")
      (str/replace #"/" "-")
      (str/replace #"\|" "-")
      (str/replace #"\\" "-")
      (str/replace #"&" "and")
      (str/replace #" " "-")))

(defn parse-url [url]
  (let [[xurl & rest] (str/split url #"[\?&]")
        xr (map #(str/split % #"=") rest)
        keys (map keyword (into [:full-url :url] (map first xr)))
        vals (into [url xurl] (map second xr))]
    (zipmap keys vals)))

#+END_SRC

** yt-clip
Src of the yt-dl and ffmpeg commands from

[[https://unix.stackexchange.com/a/388148]]


Add capability to clip! local videos. this would not require yt-dl.
Idea from Maikerusan

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn yt-url->video-data [url]
  (let [[title video-url audio-url]
        (-> (sh "youtube-dl" 
                "--get-title" "--youtube-skip-dash-manifest" "-g" url)
            (:out)
            (str/split-lines))]
    {:title title
     :audio-url audio-url
     :video-url video-url}))

(defn save-clip! [video-url audio-url time dur fname]
  (sh "ffmpeg" 
      "-ss" (str time)
      "-i" video-url
      "-ss" (str time)
      "-i" audio-url
      "-map" "0:v" "-map" "1:a"
      "-t" (str dur)
      "-y" fname))

(defn clip!
  ([name url duration]
   (let [urlp (parse-url url)
         data (yt-url->video-data (:full-url urlp))
         video-url (:video-url data)
         audio-url (:audio-url data)
         start-time (seconds->timestamp (read-string (:t urlp)))
         fname (str name ".mov")]
     (save-clip! video-url audio-url start-time duration fname)))
  
  ([name url start-time duration]
   (let [urlp (parse-url url)
         data (yt-url->video-data (:full-url urlp))
         video-url (:video-url data)
         audio-url (:audio-url data)
         fname (str name ".mov")]
     (save-clip! video-url audio-url start-time duration fname))))

#+END_SRC

** png!
Consider trying batik-rasterize library.

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn png! [fname svg-data]
  (sh "convert" "-background" "none" "/dev/stdin" fname
      :in (html svg-data)))

#+end_src

** layering
Build a tool that correctly builds a filter complex for overlay.
single layer is a map of x,y,t where x and y are position from top left corner in pixels, and t is time offset from 0 seconds. First layer in sequence passed in is the base layer.

transparent webm layering:

ffmpeg -vcodec libvpx-vp9 -i in1.webm 
       -vcodec libvpx-vp9 -i in2.webm
       -filter_complex overlay 
       circles.webm




-filter_complex
[0:v][1:v]overlay=20:20:shortest=1[over001];
[over001][2:v]overlay=500:500:shortest=1[over002];
[over002][3:v]overlay=500:500:shortest=1


n = 0 should not happen

""


n = 1

"[0:v][1:v]overlay=X1:Y1:shortest=1[over001]"

1 < n < nmax

"[over00N-1][N:v]overlay=XN:YN:shortest=1[over00N]"


n = (count layers) = nmax

"[over00N-1][N:v]overlay=XN:YN:shortest=1"





note on map-indexed:

Works similarly to map, but will give two args to the function you are mapping. They are, the index of the item, and the item itself.

It can only take 1 collection.

So, (map-indexed vector [:a :b :c]) returns

([0 :a] [1 :b] [2 :c])

because you can think of it like this:
(vector idx itm) so, for the first item: (vector 0 :a) and so on.

(map f (range) as bs cs)

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
;; z-index suggested by maacl72
(defn- layer-input-partial [{:keys [file]}]
  (let [[name ext] (str/split file #"\.")]
    (concat 
     (when (= ext "webm") ["-vcodec" "libvpx-vp9"])
     ["-i" file])))

(defn- layer-input
  [layers]
  (vec (mapcat layer-input-partial layers)))

(defn- layer-filter-complex-partial
  [nmax [{px :x py :y pz :z :as pl} {cx :x cy :y n :z :as cl}]]
  (cond
    (= n 0) ""
    (and (= n 1) (= n nmax)) (str "[0:v][1:v]overlay=" cx ":" cy "")
    (= n 1) (str "[0:v][1:v]overlay=" cx ":" cy "[over001];")
    (< 1 n nmax) (str (format "[over%03d]" (dec n)) "[" n ":v]overlay=" cx ":" cy (format "[over%03d];" n))
    (= n nmax) (str (format "[over%03d]" (dec n)) "[" n ":v]overlay=" cx ":" cy)))

(defn- layer-filter-complex
  [layers]
  (let [nlayers (dec (count layers))
        layers (sort-by :z layers)]
    ["-filter_complex"
     (str/join " " (map (partial layer-filter-complex-partial nlayers) (partition 2 1 layers)))]))

(defn layer
  [fname layers]
  (apply sh (concat
             ["ffmpeg"]
             (layer-input layers)
             (layer-filter-complex layers)
             ["-c:a" "copy" "-map" "0:a:0"]
             ["-y" fname])))

(def example-layers 
  [{:file "clip001-bb.mov" :x 0 :y 0 :z 0}
   {:file "drw2.webm" :x 0 :y (- 1080 600) :z 1}])
#+END_SRC

** chroma
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj


#+end_src

** crop-pad-screen
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn pad-screen
  [{:keys [fname left right] :as m}]
  (let [[w h] (get-resolution fname)
        props (merge m {:border {:width 0 :color ""}
                        :base-dims [1920 1080]
                        :overlay-dims [(+ (:width left) (:width right)) h]})
        [ow oh] (overlay-offsets props)
        col (get-bg-color fname)]
    (sh "ffmpeg"
        "-i" fname
        "-f" "lavfi" 
        "-i" (str "color=" col ":s=1920x1080")
        "-filter_complex"
        (str "[1:v][0:v]overlay=" ow ":" oh ":shortest=1")
        "-c:a" "copy" "-y" "cropped-screen.mov")))

(defn crop-pad-screen
  "A multi-step transformation for screen recording footage.
  
  The following sequence of transforms are handled using ffmpeg's 'filter_complex':
   - crop and pad screen recording
   - cut screen footage into left side and right side
   - create a 1920x1080 image with the background color as the fill
   - stitch left and right side back together
   - overlay stitched screen recording onto the bg image with calculated offset values"
  [{:keys [fname left right] :as m}]
  (let [[w h] (get-resolution fname)
        props (merge m {:border {:width 0 :color ""}
                        :base-dims [1920 1080]
                        :overlay-dims [(+ (:width left) (:width right)) h]})
        [ow oh] (overlay-offsets props)
        col (get-bg-color fname)]
    (sh "ffmpeg"
        "-i" fname
        "-f" "lavfi" 
        "-i" (str "color=" col ":s=1920x1080")
        "-filter_complex"
        (str "[0:v]crop=" (:width left) ":" h ":" (:offset left) ":0[l];"
             "[0:v]crop=" (:width right) ":" h ":" (- w (:width right) (:offset right)) ":0[r];"
             "[l][r]hstack=inputs=2[scr];"
             "[1:v][scr]overlay=" ow ":" oh ":shortest=1")
        "-c:a" "copy" "-y" "cropped-screen.mov")))

#+end_src

** overlay-camera
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn clap-time
  "Find time in seconds at which a clap is detected in the audio stream of fname.
  
  The detection assumes that a clap sound exists within the first 12 seconds of a given clip."
  [fname]
  (->> (sh "ffmpeg" "-i" fname
           "-ss" "00:00:00" "-t" "00:00:12" 
           "-af" "silencedetect=noise=0.6:d=0.01"
           "-f" "null" "-")
       :err
       (str/split-lines)
       (drop-while #(not (str/includes? % "silence_end:")))
       (first)
       (re-find #"silence_end: .+")
       (re-find #"\d+\.\d+")
       (read-string)))

(defn overlay-camera
  "Composes the final footage by overlaying the camera footage onto the screen footage according to given properties.
  
  The composition is handled using ffmpeg's 'filter_complex', and several actions occur:
   - overlays camera footage with border onto screen footage
   - given screen footage, camera footage, and border width and color create combined video
   - calculate camera delay using clap times in footage. assumes screen recording is longer than cam
   - calculate size of border for camera
   - create border as a solid color frame
   - scale camera down to given overlay-dims
   - overlay camera onto border frame
   - overlay bordered camera onto screen footage with calculated offsets"
  [{:keys [border overlay-dims camf scrf] :as props}]
  (let [{:keys [width color]} border
        [cw ch] (map #(+ (* 2 width) %) overlay-dims)
        [ow oh] (overlay-offsets (assoc props :fname scrf 
                                        :base-dims (get-resolution scrf)))
        delay (- (clap-time scrf) (clap-time camf))]
    (sh "ffmpeg"
        "-i" scrf
        "-i" camf
        "-f" "lavfi" 
        "-i" (str "color=" color ":s=" cw "x" ch)
        "-filter_complex"
        (str "[1:v]scale=" (apply str (interpose "x" overlay-dims)) "[scv];"
             "[2:v][scv]overlay=" width ":" width ":shortest=1[cam];"
             "[cam]setpts=PTS-STARTPTS+" delay "/TB[dcam];"
             "[0:v][dcam]overlay=" ow ":" oh ":shortest=1")
        "-c:a" "copy" "-y" "merged.mov")))

#+end_src

** fix-mono-audio
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn fix-audio
  "Fixes issue where mono audio track plays only to the Left channel."
  [fname]
  (sh "ffmpeg" "-i" fname
      "-i" fname "-af" "pan=mono|c0=FL"
      "-c:v" "copy" "-map" "0:v:0" "-map" "1:a:0" "fixed-audio.mov"))

#+end_src

** blur-border-resize
Use this to turn lower res footage into higher res footage by scale/blur/overlay, just like 'nicer vertical' but centering the original footage.

This is mostly used for turning 720p footage into neat looking 1080p for highlight videos or something like that.

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn blur-border-resize
  [fname]
  (let [[name ext] (str/split fname #"\.")
        nfname (apply str [name "-bbr" "." ext])]
    (sh "ffmpeg"
        "-i" fname
        "-filter_complex"
        (str "[0:v]scale=1920:-1[sc1];"
             "[0:v]scale=1280:-1[sc2];"
             "[sc1]gblur=sigma=75[blur];"
             "[blur][sc2]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2:shortest=1")
        "-c:a" "copy" "-y" nfname)))

#+END_SRC

** blur-border
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn blur-border
  [fname backw backh forew foreh]
  (let [[name ext] (str/split fname #"\.")
        nfname (apply str [name "-bb" "." ext])]
    (sh "ffmpeg"
        "-i" fname
        "-filter_complex"
        (str "[0:v]scale=" backw ":" backh "[sc1];"
             "[0:v]scale=" forew ":" foreh "[sc2];"
             "[sc1]gblur=sigma=75[blur];"
             "[blur][sc2]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2:shortest=1")
        "-c:a" "copy" "-y" nfname)))

(defn blur-uneven-border
  [fname backw backh forew foreh x y]
  (let [[name ext] (str/split fname #"\.")
        nfname (apply str [name "-bub" "." ext])]
    (sh "ffmpeg"
        "-i" fname
        "-filter_complex"
        (str "[0:v]scale=" backw ":" backh "[sc1];"
             "[0:v]scale=" forew ":" foreh "[sc2];"
             "[sc1]gblur=sigma=75[blur];"
             "[blur][sc2]overlay=" x ":" y ":shortest=1")
        "-c:a" "copy" "-y" nfname)))


#+END_SRC

** blur-border2
Come up with better structure for calling these functions.
For example, use map destructuring to combine a few of these fns into one. perhaps use defmethod to dispatch on the types of keys that are in the map you pass.

Take audio from the foreground (second video input) using -map 1:a:0 Which reads as:

"take from the 1-idx video the 0th audio track"

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn blur-border2
  [fnameb backw backh fnamef forew foreh]
  (let [[name ext] (str/split fnamef #"\.")
        nfname (apply str [name "-bb2" "." ext])]
    (sh "ffmpeg"
        "-i" fnameb
        "-i" fnamef
        "-filter_complex"
        (str "[0:v]scale=" backw ":" backh "[sc1];"
             "[1:v]scale=" forew ":" foreh "[sc2];"
             "[sc1]gblur=sigma=75[blur];"
             "[blur][sc2]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2:shortest=1")
        "-c:a" "copy" "-map" "1:a:0"
        "-y" nfname)))
#+END_SRC

** corner-col-border
Take color from the top left corner of the video and use it as background.

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn corner-col-border
  [fname backw backh forew foreh]
  (let [[name ext] (str/split fname #"\.")
        nfname (apply str [name "-ccb" "." ext])]
    (sh "ffmpeg"
        "-i" fname
        "-i" fname
        "-filter_complex"
        (str "[0:v]crop=2:2[crop1];"
             "[crop1]scale=" (max backw backh) ":" (max backw backh) "[sc1];"
             "[sc1]crop=" backw ":" backh "[crop2];"
             "[1:v]scale=" forew ":" foreh "[sc2];"
             "[crop2][sc2]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2:shortest=1")
        "-c:a" "copy" "-map" "0:a:0"
        "-y" nfname)))

(defn corner-col-uneven-border
  [fname backw backh forew foreh x y]
  (let [[name ext] (str/split fname #"\.")
        nfname (apply str [name "-ccub" "." ext])]
    (sh "ffmpeg"
        "-i" fname
        "-i" fname
        "-filter_complex"
        (str "[0:v]crop=2:2[crop1];"
             "[crop1]scale=" (max backw backh) ":" (max backw backh) "[sc1];"
             "[sc1]crop=" backw ":" backh "[crop2];"
             "[1:v]scale=" forew ":" foreh "[sc2];"
             "[crop2][sc2]overlay=" x ":" y ":shortest=1")
        "-c:a" "copy" "-map" "0:a:0"
        "-y" nfname)))

#+END_SRC

** static-bg
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn static-bg
  [fnameb backw backh fnamef forew foreh]
  (let [[name ext] (str/split fnamef #"\.")
        nfname (apply str [name "-sb" "." ext])]
    (sh "ffmpeg"
        "-i" fnameb
        "-i" fnamef
        "-filter_complex"
        (str "[0:v]scale=" backw ":" backh "[sc1];"
             "[1:v]scale=" forew ":" foreh "[sc2];"
             "[sc1][sc2]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2")
        "-c:a" "copy" "-map" "1:a:0"
        "-y" nfname)))

#+end_src

** nicer-vertical
Make vertical footage look better by scaling and blurring the footage to fill black bars.

- scale original clip up so that width is 1920, keep clip centered and crop height to 1080p
- apply gaussian blur
- scale original clip so height is 1080p
- overlay on blurred footage at center of clip

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn nicer-vertical
  [fname]
  (let [[name ext] (str/split fname #"\.")
        nfname (apply str [name "-nice" "." ext])]
    (sh "ffmpeg"
        "-i" fname
        "-filter_complex"
        (str "[0:v]scale=w=in_h:h=-1[sc1];"
             "[sc1]crop=in_w:1080[crop];"
             "[crop]gblur=sigma=85[blur];"
             "[0:v]scale=w=-1:h=in_w[sc2];"
             "[blur][sc2]overlay=(main_w-overlay_w)/2:0:shortest=1")
        "-map" "0:a" "-c:a" "copy" "-y" nfname)))

#+end_src

** cut-silence
Use this to get sequence of silence timestamps and durations. Then, try to cut and re-concat videos to elminate silence.

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn get-sounds
  [fname]
  (->> (sh "ffmpeg" "-i" fname
           "-af" "silencedetect=n=-37dB:d=0.7"
           "-f" "null" "-")
       :err
       (str/split-lines)
       (map #(re-find #"silence_.+" %))
       (filter #(not (nil? %)))
       (map #(re-find #"\d+\.?(\d+)?" %))
       (map first)
       (map read-string)
       (rest)
       (partition 2)
       (map #(zipmap [:s :e] %))))

(defn clip-video
  [fname {:keys [s e]}]
  (let [dur (- e s)
        tmpf (str (str/replace (str s) "." "_")
                  "-" fname)]
    (sh "ffmpeg" "-i" fname 
        "-ss" (str s) "-t" (str dur)
        tmpf)))

(defn cut-merge
  [fname times]
  (let [fnames (map 
                #(str (str/replace (str (:s %)) "." "_")
                      "-" fname)
                times)]
    ;; create clips
    (doall (pmap #(clip-video fname %) times))
    ;; create clips file list
    (spit (str fname ".txt")
          (apply str (map #(str "file '" % "'\n") fnames)))
    ;; concat clips together
    (sh "ffmpeg" "-f" "concat" "-safe" "0"
        "-i" (str fname ".txt") "-c" "copy"
        (str "initial-cut" (get-extension fname)))
    ;; delete tmp files
    (mapv #(sh "rm" %) fnames)
    (sh "rm" (str fname ".txt"))))
#+END_SRC

** graphics
Matrix transform for isometric view from:

[[https://www.petercollingridge.co.uk/tutorials/svg/isometric-projection/]]

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(def font-import
  [:style "
@import url('https://fonts.googleapis.com/css2?family=Oswald:wght@600&display=swap');

"])


(defn iso-text [text]
  (->> (svg/text text)
       (svg/style {:transform "rotate(0 0 0) matrix(0.707 0.409 -0.707 0.409 0 -0.816)"})))

(defn svg
  [[w h sc] & content]
  (assoc-in 
   (svg/svg [w h sc] 
            font-import
            content)
   [1 :viewBox]
   (str/join " " [(/ w -2.0) (/ h -2.0) w h])))

(def test-overlay
  (let [obj 
        (fn [t]
          (->> (iso-text "adam-james")
               (svg/style {:fill (str "rgb(100,170,123)")
                           :stroke (str "rgb(80,210,145)")
                           :opacity t
                           :stroke-width "1px"
                           :text-anchor "middle"
                           :font-size 120
                           :font-family "Oswald"
                           :font-weight "600"})))]
    (svg [600 600]
         (let [step 0.1]
           (for [t (range step (+ step 1) step)]
             (->> (obj t)
                  (tf/translate [(* -100 t) (* -100 t)])))))))
#+END_SRC

** iso-title
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn iso-title
  [s]
  (let [obj 
        (fn [t]
          (->> (iso-text s)
               (svg/style {:fill (str "rgb(100,170,123)")
                           :stroke (str "rgb(80,210,145)")
                           :opacity t
                           :stroke-width "1px"
                           :text-anchor "middle"
                           :font-size 120
                           :font-family "Oswald"
                           :font-weight "600"})))]
    (svg [600 600]
         (let [step 0.1]
           (for [t (range step (+ step 1) step)]
             (->> (obj t)
                  (tf/translate [(* -100 t) (* -100 t)])))))))

#+END_SRC

** animation
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn- anim-frames! [f name framerate dur]
  (let [mkdir (sh "mkdir" "-pv" name)
        frames (int (* framerate dur))
        framefn (fn [fr] (png! 
                          (format (str name "/%03d.png") fr)
                          (f (/ fr frames))))]
    (when (= 0 (:exit mkdir))
      (into [] (map framefn (range 1 (inc frames)))))))

(defn- anim-video! [name framerate]
  (let [ffmpeg 
        (sh "ffmpeg" "-f" "image2" "-r" (str framerate)
            "-i" (str name "/%03d.png")
            "-c:v" "libvpx-vp9" "-vf" "format=rgba"
            "-pix_fmt" "yuva420p" "-b:v" "800k"
            "-y" (str name ".webm"))]
    (when (= 0 (:exit ffmpeg))
      (sh "rm" "-rf" name))))

(defn animate! [{:keys [graphics-fn name framerate duration]}]
  (do (anim-frames! graphics-fn name framerate duration)
      (anim-video! name framerate)))

#+END_SRC

** animate-examples
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn ease-in-out-cubic [t]
  (if (< t 0.5)
    (* 4 t t t)
    (- 1 (/ (Math/pow (+ 2 (* t -2)) 3) 2))))

(def circle-anim
  {:name "circle"
   :framerate 30
   :duration 4
   :graphics-fn
   (fn [t]
     (let [nt (ease-in-out-cubic t)]
       (svg [600 600]
            (->> (svg/circle 35)
                 (tf/translate [-300 -300])
                 (tf/translate [(* nt 600) (* nt 600)])
                 (svg/style {:fill "pink"
                             :stroke "hotpink"
                             :stroke-width "4px"})))))})

(def draw-anim
  {:name "drw"
   :framerate 60
   :duration 4
   :graphics-fn
   (fn [t]
     (let [nt (ease-in-out-cubic t)]
       (svg
        [600 600]
        (->> (svg/rect 600 600)
             (svg/style {:fill "rgb(45,52,64)"}))
        (->> (iso-text "adam-james")
             (svg/style {:fill "none"
                         :stroke-dasharray 600
                         :stroke-dashoffset (* 600 (- 1 nt))
                         :text-anchor "middle"
                         :stroke-width "1px"
                         :stroke "hotpink"
                         :font-family "Oswald"
                         :font-weight "600"
                         :font-size "120"})))))})

(def palette ["#5E81AC"
              "#81a1c1"
              "#8fbcbb"
              "#bf616a"
              "#d08770"
              "#ebcb8b"
              "#a3be8c"
              "#b48ead"
              "#88c0d0"])

(defn draw-title
  [text]
  (let [col (get palette (rand-int (count palette)))]
    (fn [t]
      (let [nt (ease-in-out-cubic t)]
        (svg
         [600 600 1]
         (->> (iso-text text)
              (tf/translate [5 5])
              (svg/style {:fill "none"
                          :opacity 0.15
                          :stroke-dasharray 600
                          :stroke-dashoffset (* 600 (- 1 nt))
                          :text-anchor "middle"
                          :stroke-width "2px"
                          :stroke "#eceff4"
                          :font-family "Oswald"
                          :font-weight "600"
                          :font-size "100"}))
         (->> (iso-text text)
              (tf/translate [2.5 2.5])
              (svg/style {:fill "none"
                          :opacity 0.5
                          :stroke-dasharray 600
                          :stroke-dashoffset (* 600 (- 1 nt))
                          :text-anchor "middle"
                          :stroke-width "2px"
                          :stroke "#eceff4"
                          :font-family "Oswald"
                          :font-weight "600"
                          :font-size "100"}))
         (->> (iso-text text)
              (svg/style {:fill "none"
                          :stroke-dasharray 600
                          :stroke-dashoffset (* 600 (- 1 nt))
                          :text-anchor "middle"
                          :stroke-width "2px"
                          :stroke col
                          :font-family "Oswald"
                          :font-weight "600"
                          :font-size "100"})))))))

(defn draw-text
  [text]
  (let [col (get palette (rand-int (count palette)))]
    (fn [t]
      (let [nt (ease-in-out-cubic t)]
        (svg
         [900 300 1]
         (->> (svg/text text)
              (tf/translate [0 2])
              (svg/style {:fill "none"
                          :opacity 0.15
                          :stroke-dasharray 600
                          :stroke-dashoffset (* 600 (- 1 nt))
                          :text-anchor "middle"
                          :stroke-width "2px"
                          :stroke "#eceff4"
                          :font-family "Menlo"
                          :font-size "29"}))
         (->> (svg/text text)
              (tf/translate [0 1])
              (svg/style {:fill "none"
                          :opacity 0.5
                          :stroke-dasharray 600
                          :stroke-dashoffset (* 600 (- 1 nt))
                          :text-anchor "middle"
                          :stroke-width "2px"
                          :stroke "#eceff4"
                          :font-family "Menlo"
                          :font-size "29"}))
         (->> (svg/text text)
              (svg/style {:fill "none"
                          :stroke-dasharray 600
                          :stroke-dashoffset (* 600 (- 1 nt))
                          :text-anchor "middle"
                          :stroke-width "2px"
                          :stroke col
                          :font-family "Menlo"
                          :font-size "29"})))))))

(def draw-anim2
  {:name "drw2"
   :framerate 30
   :duration 4
   :graphics-fn (draw-text "This is a short sentence explaining the clip.")})


(comment
  (animate! circle-anim)
  (animate! circle2-anim)
  ;; WIP
  (layer "circles.webm"
         [{:file "circle.webm" :x 0 :y 0 :t 0}
          {:file "circle2.webm" :x 0 :y 0 :t 0}])
  )
#+END_SRC

** assets
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(def title-anim
  {:name "twitch"
   :framerate 60
   :duration 5
   :graphics-fn
   (fn [t]
     (let [nt (ease-in-out-cubic t)]
       (svg/svg 
        [1920 1080 1]
        #_(->> (svg/circle (* 1200 2 nt))
             (tf/translate [960 540])
             (svg/style {:fill "rgb(45,52,64)"}))
        (->> (svg/text "twitch.tv/adam_james_tv")
             (tf/rotate 0)
             (tf/translate [960 540])
             (tf/translate [0 450])
             (svg/style {:fill "#FEFEFE"
                         :opacity "0.90"
                         :text-anchor "middle"
                         :font-family "Oswald"
                         :font-weight "600"
                         :font-size "120px"}))
        (->> (svg/text "twitch.tv/adam_james_tv")
             (tf/rotate 0)
             (tf/translate [960 540])
             (tf/translate [0 450])
             (svg/style {:fill "#9146FF"
                         :opacity "0.25"
                         :text-anchor "middle"
                         :font-family "Oswald"
                         :font-weight "600"
                         :font-size "120px"}))
        (->> (svg/text "twitch.tv/adam_james_tv")
             (tf/rotate 0)
             (tf/translate [960 540])
             (tf/translate [0 450])
             (svg/style {:fill "none"
                         :stroke-dasharray 700
                         :stroke-dashoffset (* 700 (- 1 nt))
                         :stroke-width "2px"
                         :stroke "#9146FF"
                         :text-anchor "middle"
                         :font-family "Oswald"
                         :font-weight "600"
                         :font-size "120px"})))))})

#+END_SRC

** stream-highlighting-proto
This is a prototype pipeline for auto-generating neat looking stream clips

Flow is:

(url start duration) ->
(clip!) 
(blur-border 'effect') -> A

(url start duration) ->
(animate! title) -> B

(layer a b) -> clip

After all clips made,

(concat clips)



#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj


;; input
(def sample-clip
  {:fname "sample.mov"
   :url "https://youtu.be/NDo0fmRshrM?t=6663"
   :duration 40
   :title "OpenSCAD Basics"
   :descr "Showing what union() and difference() do"})

;; messy, but it works!!
(defn stream-highlight-clip!
  [{:keys [fname url duration title descr] :as clipm}]
  (let [[name ext] (str/split fname #"\.")
        anim-name (str name "/anim")
        anim2-name (str name "/anim2")
        base-clip-name (str name "/base-clip")
        xf-clip-name (str name "/base-clip-bub.mov")]
    ;; create clip directory
    (sh "mkdir" "-pv" (str name))
    ;; create all animation layers
    (animate! {:name anim-name 
               :duration 5
               :framerate 30
               :graphics-fn (draw-title title)})
    (animate! {:name anim2-name
               :duration 3
               :framerate 30
               :graphics-fn (draw-text descr)})
    ;; retrieve the base clip
    (clip! base-clip-name url duration)
    ;; clip 'effect'
    (blur-uneven-border (str base-clip-name ".mov") 1920 1080 1600 900 300 20)
    ;; compose all layers
    (layer fname 
           [{:file xf-clip-name :x 0 :y 0 :z 0}
            {:file (str anim-name ".webm") :x -30 :y (- 1080 500) :z 1}
            {:file (str anim2-name ".webm") :x (- 1920 1000) :y (- 1080 250) :z 2}])
    ;; can delete intermediate files, but probably good to keep them
    #_(sh "rm" "-rf" (str name))))


#+END_SRC

** crossfade-scratch

[[https://superuser.com/a/1643589]]

ffmpeg -i clip001.mov -i clip002.mov \
-filter_complex \
"color=black:1920x1080:d=96.000[base]; \
[0:v]setpts=PTS-STARTPTS[v0]; \
[1:v]format=yuva420p,fade=in:st=0:d=2:alpha=1,setpts=PTS-STARTPTS+((75-2)/TB)[v1]; \
[base][v0]overlay[tmp]; \
[tmp][v1]overlay,format=yuv420p[fv]; \
[0:a][1:a]acrossfade=d=2[fa]" \
-map "[fv]" -map "[fa]" out.mov


ffmpeg -i clip001.mov -i clip002.mov \
-filter_complex \
"color=black:1920x1080:d=__TOTAL_DIR__[base]; \
[0:v]setpts=PTS-STARTPTS[v0]; \
[1:v]format=yuva420p,fade=in:st=0:d=__CROSS_DUR__:alpha=1,setpts=PTS-STARTPTS+(__A_DUR__/TB)[v1]; \
[base][v0]overlay[tmp]; \
[tmp][v1]overlay,format=yuv420p[fv]; \
[0:a][1:a]acrossfade=d=__CROSS_DUR__[fa]" \
-map "[fv]" -map "[fa]" out.mov

__TOTAL_DUR__ = (+ clip-a-dur clip-b-dur (- crossfade-dur))
__CROSS_DUR__ = crossfade-dur
__A_DUR__ = (- clip-a-dur crossfade-dur)

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn crossfade
  [[fnamea fnameb] dur]
  (let [[namea exta] (str/split fnamea #"\.")
        [nameb extb] (str/split fnameb #"\.")
        nameb (last (str/split nameb #"/"))
        fname (str namea "-" nameb "." exta)
        dura (get-duration fnamea)
        durb (get-duration fnameb)
        [w h] (get-resolution fnamea)
        total-dur (+ dura durb (- dur))]
    (sh "ffmpeg"
        "-i" fnamea
        "-i" fnameb
        "-filter_complex"
        (str "color=black:1920x1080:d=" total-dur "[base];"
             "[0:v]setpts=PTS-STARTPTS[v0];"
             "[1:v]format=yuva420p,fade=in:st=0:d=" dur ":alpha=1,setpts=PTS-STARTPTS+(" (- dura dur) "/TB)[v1];"
             "[base][v0]overlay[tmp];"
             "[tmp][v1]overlay,format=yuv420p[fv];"
             "[0:a][1:a]acrossfade=d=" dur "[fa]")
        "-map" "[fv]" "-map" "[fa]"
        "-y" fname)))

#+END_SRC

** cli
I'll need to come up with a more general CLI that lets me do the various things I want. Not every video project needs the same functionality, so having a single expected map format as the input isn't quite useful enough.

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(def example-props
    {:screen
     {:fname "scr.mov"
      :left {:width 667 :offset 0}
      :right {:width 750 :offset 0}
      :gap 100
      :pos {:h :l :v :c}}

     :camera
     {:camf "cam.mov"
      :scrf "cropped-screen.mov"
      :border {:width 7 :color "cyan"}
      :overlay-dims [480 270]
      :gap 70
      :pos {:h :r :v :b}}})

(defn stream-highlighter
  []
  (let [fname (first *command-line-args*)
        clips (when (= (get-extension fname) ".edn")
                (read-string (slurp fname)))]
    (do
      (println (str "Total Seconds: " (reduce + (map :duration clips))))
      (mapv stream-highlight-clip! clips)
      #_(println "done"))))

(defn main
  "Main runs when vidwiz is run as a script.
  
  You can run this program with babashka:
   - chmod +x vidwiz.clj
   - ./vidwiz props.edn"
  []
  (let [fname (first *command-line-args*)
        props (when (= (get-extension fname) ".edn")
                (read-string (slurp fname)))]
    (when props
      (crop-pad-screen (:screen props))
      (pad-screen (:screen props))
      (overlay-camera  (:camera props))
      (fix-audio "merged.mov")
      (sh "cp" "fixed-audio.mov" "_precut.mov"))))

#_(stream-highlighter)

#+end_src
