* scripts
#+Title: scripts
#+AUTHOR: adam-james
#+STARTUP: overview
#+EXCLUDE_TAGS: excl
#+PROPERTY: header-args :cache yes :noweb yes :results none :mkdirp yes :padline yes :async
#+HTML_DOCTYPE: html5
#+OPTIONS: toc:2 num:nil html-style:nil html-postamble:nil html-preamble:nil html5-fancy:t

** readme
The readme
#+begin_src markdown :tangle ./readme.md
# adam-james-scripts

A collection of scripts. Primarily built with Clojure/babashka, but may use other methods occasionally.

This is a long-term, slow moving project, perhaps only ever useful to me. But I like the idea of keeping some utility scripts nicely organized in this repo.

Notes can be found in the [scripts.org](https://github.com/adam-james-v/scripts/blob/main/scripts.org) file at the top level of this project.

Everything's free to use and modify.

## Usage
I use scripter.clj and uberscripter.clj to 'build' my src scripts. 

```
bb uberscripter.clj src/some-script.clj
```

Uberscripter uses babashka's --uberscript option to create a single-file script. It looks at the file's deps and copies code into the file.

Scripter is much simpler and just copies a src script into build and makes it executable. This is useful for situations where a script doesn't work nicely with uberscript, for example, if your script uses clojure.spec.

The build folder is on my PATH env variable, so as soon as a script is moved and made executable, it becomes available from anywhere. You will need to start a new terminal session or refresh your current one to see this take effect.

#+end_src

* uberscripter
Run this from the top level of the scripts folder to create an uberscript in the build folder.

Example:

bb uberscripter src/clj-to-scad.clj

creates the file build/clj-to-scad.uber.clj

Uberscripter assumes that the first line in the script is the shebang line. Then, it assumes that the second form will be in the form:

#+begin_src clojure
(babashka.deps/add-deps '{:deps your-deps-map})
#+end_src

It's a naive approach, but if you have that initial format for your script, uberscripter will properly find deps and build a classpath.

#+begin_src clojure :tangle ./uberscripter.clj
(ns uberscripter.core
  (:require [babashka.classpath :refer [add-classpath]]
            [clojure.string :as st]
            [clojure.java.shell :refer [sh]]))

(defn get-deps
  [f]
  (->> (slurp f)
       (format "[%s]")
       read-string
       first
       second
       second
       str
       (sh "clojure" "-Spath" "-Sdeps")
       :out
       st/trim))

(defn remove-deps
  [f]
  (->> (slurp f)
       (format "[%s]")
       read-string
       rest
       (interpose "\n\n")
       (apply str)))

(defn split-fname
  [fname]
  (let [sf (st/split fname #"\.")]
    [(apply str (drop-last sf))
     (last sf)]))

(defn split-folders
  [name]
  (let [sf (st/split name #"/")]
    (vec sf)))

(defn build
  [f]
  (let [[name ext] (split-fname f)
        sname (split-folders name)
        xfname (if (= (first sname) "src")
                 (apply str (conj (rest sname) "build/"))
                 (apply str (interpose "/" sname)))
        fout (str xfname ".uber." ext)
        ftemp (str f ".tmp")]
    (spit ftemp (remove-deps f))
    (sh "bb" "--classpath" (get-deps f)
        "-f" ftemp "--uberscript" fout)
    (sh "rm" ftemp)
    (->> (slurp fout)
         (str "#!/usr/bin/env bb\n\n")
         (spit fout))
    (println fout)
    (sh "chmod" "+x" fout)))

(defn main
  []
  (let [f (first *command-line-args*)]
    (println (str "Building script: " f))
    (build f)
    #_(println (get-deps f))))

(main)
#+end_src
* scripter
Run this from the top level of the scripts folder to create a standard script in the build folder.

Example:

bb scripter src/clj-to-scad.clj

creates the file build/clj-to-scad.clj

This is meant to be used for projects that have trouble being built with the uberscripter.

#+begin_src clojure :tangle ./scripter.clj
(ns scripter.core
  (:require [babashka.classpath :refer [add-classpath]]
            [clojure.string :as st]
            [clojure.java.shell :refer [sh]]))

(defn split-fname
  [fname]
  (let [sf (st/split fname #"\.")]
    [(apply str (drop-last sf))
     (last sf)]))

(defn split-folders
  [name]
  (let [sf (st/split name #"/")]
    (vec sf)))

(defn move
  [f]
  (let [[name ext] (split-fname f)
        sname (split-folders name)
        xfname (if (= (first sname) "src")
                 (apply str (conj (rest sname) "build/"))
                 (apply str (interpose "/" sname)))
        fout (str xfname "." ext)]
    (println fout)
    (sh "chmod" "+x" fout)))

(defn main
  []
  (let [f (first *command-line-args*)]
    (println (str "Moving script: " f))
    (move f)
    #_(println (get-deps f))))

(main)
#+end_src
* clj->scad
Builds .clj files using the scad-clj library. Result is a compiled .scad file.

The script does not require any programs to be installed, though you may want to have OpenSCAD to be able to see the result.

This could be useful in a file-watcher pipeline.

** deps
#+begin_src clojure :tangle ./src/clj-to-scad.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {scad-clj/scad-clj {:mvn/version "0.5.3"}}
   #_{scad-clj/scad-clj {:local/root "/Users/adam/dev/scad-clj"}}})
#+end_src

** main
#+begin_src clojure :tangle ./src/clj-to-scad.clj
(ns clj-to-scad.main
  (:require [clojure.string :as st]
            [scad-clj.model :refer :all]
            [scad-clj.scad :refer [write-scad]]))

(defn build
  [f]
  (let [fout (-> f (st/split #"\.") first (str ".scad"))]
    (->> (slurp f)
         (format "[%s]")
         load-string
         (filter (complement var?))
         write-scad
         (spit fout))))

(build (first *command-line-args*))
#+end_src

* clj->step
Builds .clj files into .step files using freecad. Prototype status.

Some notes from Grazfather:

use the <() to make pseudo files this is the 'process substitution' operator

eg. 
echo <(echo hello)
cat <(echo hello)

diff <(xxd bin1) <(xxd bin2)

I can use the above to clean up the python script/freecad invocation. basically eliminating the need to spit fcscript.py to disk.

This script requires my local scad-clj fork (sorry). That's because it needs to emit csg, not scad (an undocumented subset of scad language).

It also requires an installation of freecad, so it's a heavy project for the time being.

** deps
#+begin_src clojure :tangle ./src/clj-to-step.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {scad-clj/scad-clj {:local/root "/Users/adam/dev/scad-clj"}}})
#+end_src

** main
#+begin_src clojure :tangle ./src/clj-to-step.clj
(ns clj-to-step.main
  (:require [clojure.string :as st]
            [clojure.java.shell :refer [sh]]
            [scad-clj.model :refer :all]
            [scad-clj.csg :refer [write-csg]]))

(def this-directory (->> (sh "pwd")
                         :out
                         st/trim))

(defn exporter-script [ipath opath]
  (str "
import FreeCAD
import importCSG
import Import

App.newDocument(\"a\")
doc = FreeCAD.getDocument(\"a\")
importCSG.insert(u\"" ipath "\", \"a\")
__objs__ = doc.RootObjects
Import.export(__objs__, u\"" opath "\")
del __objs__"))

(defn scad->step
  [f scad-block]
  (let [path this-directory]
    (->> scad-block
         write-csg
         (spit "scadout.csg"))
    (->> (str path "/" f)
         (exporter-script (str path "/scadout.csg"))
         (spit "fcscript.py"))
    (sh "freecad" "fcscript.py")
    (sh "rm" "-rf" 
        "fcscript.py"
        "parsetab.py"
        "scadout.csg"
        "__pycache__")))

(defn build
  [f]
  (let [fout (-> f (st/split #"\.") first (str ".step"))]
    (->> f
         slurp
         (format "[%s]")
         load-string
         (filter (complement var?))
         (scad->step fout))))

#_(println this-directory)
(build (first *command-line-args*))
#+end_src
* clj->svg
Builds .clj files using the scad-clj library. Result is a compiled .scad file.

** deps
#+begin_src clojure :tangle ./src/clj-to-svg.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {borkdude/spartan.spec {:git/url "https://github.com/borkdude/spartan.spec"
                               :sha "e5c9f40ebcc64b27b3e3e83ad2a285ccc0997097"}
    svg-clj/svg-clj {:git/url "https://github.com/adam-james-v/svg-clj"
                     :sha "aaf78937d7a59e11aa7b193c2f9da35d9d159ca6"}}
   :classpath-overrides {org.clojure/clojure nil
                         org.clojure/spec.alpha nil
                         org.clojure/core.specs.alpha nil}})
#+end_src

** main
#+begin_src clojure :tangle ./src/clj-to-svg.clj
(ns clj-to-svg.main
  (:require [spartan.spec :as s]
            [clojure.string :as st]
            [svg-clj.main :refer :all]
            [hiccup.core :refer [html]]))
(require '[spartan.spec])
(alias 's 'clojure.spec.alpha)

;; suggestion from Michiel @borkdude on stream
(require '[clojure.spec.alpha :as s])

(defn build
  [f]
  (let [fout (-> f (st/split #"\.") first (str ".svg"))]
    (->> (slurp f)
         (format "[%s]")
         load-string
         (filter (complement var?))
         html
         (spit fout))))

(build (first *command-line-args*))
#+end_src
* slice-anim
This doesn't work yet.

** deps
#+begin_src clojure tangle ./src/scad-slice.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {svg-clj/scad-clj {:local/root "/Users/adam/dev/scad-clj"}
    svg-clj/svg-clj {:local/root "/Users/adam/dev/svg-clj"}
    borkdude/spartan.spec {:git/url "https://github.com/borkdude/spartan.spec"
                               :sha "e5c9f40ebcc64b27b3e3e83ad2a285ccc0997097"}}})
#+end_src

** main
#+begin_src clojure tangle ./src/scad-slice.clj
(ns scad-slice.main
  (:require [spartan.spec]
            [clojure.spec.alpha :as s]
            [scad-clj.model :refer :all]
            [scad-clj.scad :refer [write-scad]]
            [svg-clj.main :as svg]
            [hiccup.core :refer [html]]
            [clojure.string :as st]
            [clojure.java.shell :refer [sh]]))

(defn f->path
  [f]
  (->> (slurp f)
       st/split-lines
       (drop 2)
       (apply str)
       svg/->edn
       svg/unwrap-elements))

(defn to-deg
  [rad]
  (* rad (/ 180 Math/PI)))

(defn to-rad
  [deg]
  (* deg (/ Math/PI 180)))

(defn round
  [num places]
  (let [d (Math/pow 10 places)]
    (/ (Math/round (* num d)) d)))

(defn sin-cos-pair [theta]
  [(Math/sin (to-rad theta)) (Math/cos (to-rad theta))])

(defn rot-pt-2d
  [[x y] theta]
  (let [[s-t c-t] (sin-cos-pair theta)]
    [(- (* x c-t) (* y s-t))
     (+ (* y c-t) (* x s-t))]))

;; this rotates a point around [0,0,0]
(defn rot-pt
  [[x y z] axis theta]
  (cond
    (= axis :x) (into [x] (rot-pt-2d [y z] theta))
    (= axis :y) (apply #(into [] [%2 y %1]) (rot-pt-2d [z x] theta))
    (= axis :z) (into (rot-pt-2d [x y] theta) [z])))

(defn rotate-point
  [pt [ax ay az]]
  (-> pt
      (rot-pt :z az)
      (rot-pt :y ay)
      (rot-pt :x ax)))

(defn rotate-points
  [pts [ax ay az]]
  (mapv #(rotate-point % [ax ay az]) pts))

(def iso-euler-angles [35.264 45 0])
(def origin-angle-adjust-a [90 0 0])
(def origin-angle-adjust-b [0 -90 0])

(defn isometric-xf
  [pts]
  (-> pts
      (rotate-points origin-angle-adjust-a)
      (rotate-points origin-angle-adjust-b)
      (rotate-points iso-euler-angles)))

(defn top-xf
  [pts]
  (-> pts
      (rotate-points [0 0 0])))

(defn right-xf
  [pts]
  (-> pts
      (rotate-points [90 0 0])))

(defn add-z [pt2d] (vec (concat pt2d [0])))
(defn drop-z [pt3d] (vec (take 2 pt3d)))
(defn round-pt [places pt] (mapv #(round % places) pt))

(defn path->path-pts
  [path]
  (->> (get-in path [1 :d])
       svg/path-string->commands
       (partition-by #(= "Z" (:command %)))
       (partition 2)
       (map vec)
       (map #(apply concat %))
       (map #(map :input %))
       (mapv #(vec (filter (complement nil?) %)))))

(defn re-zero
  [path]
  (let [[[minx miny] _ _ _] (svg/bounds path)]
    (svg/translate [(- minx) (- miny)] path)))

(defn bb-dims
  [path]
  (let [[[minx miny] _ [maxx maxy] _] (svg/bounds path)]
    [(int (Math/ceil (- maxx minx)))
     (int (Math/ceil (- maxy miny)))]))

(defn pts-bb-area
  [pts]
  (->> pts
       svg/polygon-path
       bb-dims
       (apply *)))

(defn remove-largest
  [n path]
  (let [ctr (svg/centroid path)
        rem (->> path
                 path->path-pts
                 (sort-by pts-bb-area)
                 (drop-last n))]
    (if (< 0 (count rem))
      (->> rem
           (map svg/polygon-path)
           (apply svg/merge-paths)
           vec)
      (svg/polygon-path [ ctr ]))))

(defn path->iso-path
  [path]
  (->> path
       path->path-pts
       (map #(mapv add-z %))
       (map isometric-xf)
       (map #(mapv drop-z %))
       (map #(mapv (partial round-pt 5) %))
       (map svg/polygon-path)
       (apply svg/merge-paths)
       vec
       re-zero
       (remove-largest 2)
       (svg/style {:fill "none"
                   :stroke "slategray"
                   :stroke-width "0.5px"})))

(defn vstack
  [gap elems]
  (let [elems (vec elems)]
    (->>
     (apply svg/g
            (for [y (reverse (range (count elems)))]
              (svg/translate [0 (* y gap)]
                             (get elems (- (dec (count elems)) y)))))
     re-zero)))

(defn slices->svg
  [gap slices]
  (->> slices
       (map path->iso-path)
       (vstack gap)
       (#(svg/svg (concat (bb-dims %) [1]) %))
       html
       (spit "iso-slices.svg")))

(defn scad->slice-anim
  [scad-block]
  (let [st 5]
    (pmap
      (fn [a]
        (do
         (->> scad-block
              (union (difference
                      (cube 1000 1000 1000)
                      (cube 999 999 1100)))
              (translate [0 0 (- a)])
              (scale [25.4 25.4 25.4])
              cut
              write-scad
              (spit (format "slice/%03d.scad" (int (/ a st)))))
         (sh "openscad" (format "slice/%03d.scad" (int (/ a st)))
             "-o" (format "slice/%03d.svg" (int (/ a st))))))
      (range 0 110 st))
    #_(->> (range 0 (int (/ 110 5)))
         (map #(format "slice/%03d.svg" %))
         (map f->path)
         (map first)
         (slices->svg st))))

(defn merge-slice-files
  []
  (->> (range 0 (int (/ 110 5)))
       (map #(format "slice/%03d.svg" %))
       (map f->path)
       (map first)
       (slices->svg 5)))

(defn clj->slice-anim
  [f]
  (->> f
       slurp
       (format "[%s]")
       load-string
       (filter (complement var?))
       scad->slice-anim)
  merge-slice-files)

(defn elem?
  [elem]
  (or (s/valid? :svg-clj.main/basic-element elem)
      (s/valid? :svg-clj.main/text-element elem)
      (s/valid? :svg-clj.main/g-element elem)
      (s/valid? :svg-clj.main/path-element elem)))

#_(clj->slice-anim (first *command-line-args*))
#_(merge-slice-files)
#+end_src

#+begin_src clojure :tangle ./src/scad-slice.clj
(->> "slice/006.svg"
     f->path
     first
     (#(get-in % [1 :d]))
     (s/explain :svg-clj.main/path-string)
     println)
#+end_src
* png->svg
Traces a png image and approximates it with an SVG path.

This script requires vtracer to be installed and available on your PATH.

[vtracer](https://github.com/visioncortex/vtracer)

** deps
#+begin_src clojure :tangle ./src/png-to-svg.clj
#!/usr/bin/env bb

(babashka.deps/add-deps
 '{:deps
   {borkdude/spartan.spec {:git/url "https://github.com/borkdude/spartan.spec"
                           :sha "e5c9f40ebcc64b27b3e3e83ad2a285ccc0997097"}
    org.clojure/math.combinatorics {:mvn/version "0.1.6"}
    svg-clj/svg-clj {:local/root "/Users/adam/dev/svg-clj"}
    #_{:git/url "https://github.com/adam-james-v/svg-clj"
                     :sha "aaf78937d7a59e11aa7b193c2f9da35d9d159ca6"}}
   :classpath-overrides {org.clojure/clojure nil
                         org.clojure/spec.alpha nil
                         org.clojure/core.specs.alpha nil}})
#+end_src

** ns
#+begin_src clojure :tangle ./src/png-to-svg.clj
(ns png-to-svg.main
  (:require [spartan.spec :as s]
            [clojure.string :as st]
            [clojure.math.combinatorics :as combo]
            [clojure.java.shell :refer [sh]]
            [svg-clj.main :refer :all]
            [svg-clj.utils :as utils]
            [svg-clj.specs :as specs]
            [svg-clj.transforms :as tf]
            [hiccup.core :refer [html]]))
(require '[spartan.spec])
(alias 's 'clojure.spec.alpha)

;; suggestion from Michiel @borkdude on stream
(require '[clojure.spec.alpha :as s])
#+end_src

** img->edn
#+begin_src clojure :tangle ./src/png-to-svg.clj
(defn img->str [fname]
  "Ingest image file `fname` and transform it into a hiccup data structure."
  (let [new-fname (str (first (st/split fname #"\.")) ".svg")]
    (sh "vtracer" 
        "--mode" "polygon"
        "--colormode" "bw"
        "--input" fname
        "--output" new-fname)
    (let [svg-str (slurp new-fname)]
      (sh "rm" new-fname)
      (-> svg-str
          (st/replace #"<\?xml.+>" "")
          st/trim))))

(defn str->elements
  [str]
  (->> str
       ->edn
       (drop 2)))


(defn tr
  "Translates the `elems` by `x` and `y` relative to the element(s)'s current position(s).

  For example, a shape sitting at [10 10] being translated by [10 10] will be located at [20 20] after translation."
  [[x y] & elems]
  (let [elem (first elems)
        elems (rest elems)]
    (when elem
      (cond
        (and (specs/element? elem) (= 0 (count elems)))
        (tf/translate-element [x y] elem)
        
        #_(and (specs/element? elem) (< 0 (count elems)))
        #_(concat
         [(tf/translate-element [x y] elem)]
         [(tr [x y] elems)])
      
        #_:else
        #_f(recur [x y] (concat elem elems))))))


(defn re-center
  [seq]
  (let [group (g seq)
        ctr (mapv float (centroid group))]
    (->> seq
         (map #(tf/translate-element (utils/v* [-1 -1] ctr) %)))))

#+end_src

** main
#+begin_src clojure :tangle ./src/png-to-svg.clj
(defn build
  [f]
  (let [fout (-> f (st/split #"\.") first (str ".svg"))]
    (->> f
         img->str
         str->elements
         re-center
         #_(svg [2048 2048 1]))))

(build (first *command-line-args*))
#+end_src
* vidwiz
** ns
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
#!/usr/bin/env bb

(ns vidwiz.main
  "This is a prototype script for automating a portion of my video editing using ffmpeg."
  (:require [clojure.java.shell :refer [sh]]
            [clojure.string :as str]))

#+END_SRC

** utility
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
;; utils
(defn get-extension
  [fname]
  (re-find #"\.[A-Za-z\d+]+" fname))

(defn get-resolution
  [fname]
  (->> (sh "ffprobe" "-i" fname)
       :err
       (re-find #"\d\d+x\d+")
       (#(str/split % #"x"))
       (mapv read-string)))

(defn overlay-offsets
  [{:keys [border base-dims overlay-dims pos gap fname]}]
  (let [{:keys [width]} border
        [cw ch] (map #(+ (* 2 width) %) overlay-dims)
        {:keys [h v]} pos
        [sw sh] base-dims]
    [(cond (= h :l) gap
           (= h :c) (- (/ sw 2) (/ cw 2))
           (= h :r) (- sw gap cw))
     (cond (= v :t) gap
           (= v :c) (- (/ sh 2) (/ ch 2))
           (= v :b) (- sh gap ch))]))

(defn get-bg-color
  [fname]
  (let [nfname (str/replace fname (get-extension fname) ".png")]
    (sh "ffmpeg" "-i" fname
        "-frames:v" "1"
        "-filter_complex"
        (str "[0:v]crop=4:4:100:500")
        "-y" (str nfname))
    (sh "convert" nfname "-colors" "1" nfname)
    (let [col (->> (sh "identify" "-verbose" nfname)
                   :out
                   (st/split-lines)
                   (drop-while #(not (st/includes? % "Histogram")))
                   (second)
                   (re-find #"\#......"))]
      (sh "rm" nfname)
      col)))

(defn seconds->timestamp [s]
  (let [hh (format "%02d" (int (/ s 3600)))
        mm (format "%02d" (int (/ (rem s 3600) 60)))
        ss (format "%02d" (rem s 60))]
    (apply str (interpose ":" [hh mm ss]))))

(defn clean-name [name]
  (-> name
      (str/lower-case)
      (str/replace #"!" "")
      (str/replace #"'" "")
      (str/replace #"," "")
      (str/replace #"/" "-")
      (str/replace #"\|" "-")
      (str/replace #"\\" "-")
      (str/replace #"&" "and")
      (str/replace #" " "-")))

(defn parse-url [url]
  (let [[url & rest] (str/split url #"[\?&]")
        xr (map #(str/split % #"=") rest)
        keys (map keyword (into [:url] (map first xr)))
        vals (into [url] (map second xr))]
    (zipmap keys vals)))

(defn yt-url->video-data [url]
  (let [[title video-url _ descr]
        (-> (sh "youtube-dl" "-e" "-g" "--get-description" url)
            (:out)
            (str/split-lines))]
    {:title title
     :descr descr
     :video-url video-url}))
#+END_SRC

** yt-clip
Src of the yt-dl and ffmpeg commands from

[[https://unix.stackexchange.com/a/388148]]

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn save-clip! [video-url time dur fname]
  (sh "ffmpeg" 
      "-ss" time
      "-i" video-url
      "-t" dur
      "-s" "1920x1080" 
      fname))

(defn clip! [url dur]
  (let [urlp (parse-url url)
        data (yt-url->video-data (:url urlp))
        video-url (:video-url data)
        name (clean-name (:title data))
        stime (seconds->timestamp (read-string (:t urlp)))
        fname (str name ".mov")]
    (save-clip! video-url stime dur fname)))

#+end_src

** crop-pad-screen
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn pad-screen
  [{:keys [fname left right] :as m}]
  (let [[w h] (get-resolution fname)
        props (merge m {:border {:width 0 :color ""}
                        :base-dims [1920 1080]
                        :overlay-dims [(+ (:width left) (:width right)) h]})
        [ow oh] (overlay-offsets props)
        col (get-bg-color fname)]
    (sh "ffmpeg"
        "-i" fname
        "-f" "lavfi" 
        "-i" (str "color=" col ":s=1920x1080")
        "-filter_complex"
        (str "[1:v][0:v]overlay=" ow ":" oh ":shortest=1")
        "-c:a" "copy" "-y" "cropped-screen.mov")))

(defn crop-pad-screen
  "A multi-step transformation for screen recording footage.
  
  The following sequence of transforms are handled using ffmpeg's 'filter_complex':
   - crop and pad screen recording
   - cut screen footage into left side and right side
   - create a 1920x1080 image with the background color as the fill
   - stitch left and right side back together
   - overlay stitched screen recording onto the bg image with calculated offset values"
  [{:keys [fname left right] :as m}]
  (let [[w h] (get-resolution fname)
        props (merge m {:border {:width 0 :color ""}
                        :base-dims [1920 1080]
                        :overlay-dims [(+ (:width left) (:width right)) h]})
        [ow oh] (overlay-offsets props)
        col (get-bg-color fname)]
    (sh "ffmpeg"
        "-i" fname
        "-f" "lavfi" 
        "-i" (str "color=" col ":s=1920x1080")
        "-filter_complex"
        (str "[0:v]crop=" (:width left) ":" h ":" (:offset left) ":0[l];"
             "[0:v]crop=" (:width right) ":" h ":" (- w (:width right) (:offset right)) ":0[r];"
             "[l][r]hstack=inputs=2[scr];"
             "[1:v][scr]overlay=" ow ":" oh ":shortest=1")
        "-c:a" "copy" "-y" "cropped-screen.mov")))

#+end_src

** overlay-camera
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn clap-time
  "Find time in seconds at which a clap is detected in the audio stream of fname.
  
  The detection assumes that a clap sound exists within the first 12 seconds of a given clip."
  [fname]
  (->> (sh "ffmpeg" "-i" fname
           "-ss" "00:00:00" "-t" "00:00:12" 
           "-af" "silencedetect=noise=0.6:d=0.01"
           "-f" "null" "-")
       :err
       (st/split-lines)
       (drop-while #(not (st/includes? % "silence_end:")))
       (first)
       (re-find #"silence_end: .+")
       (re-find #"\d+\.\d+")
       (read-string)))

(defn overlay-camera
  "Composes the final footage by overlaying the camera footage onto the screen footage according to given properties.
  
  The composition is handled using ffmpeg's 'filter_complex', and several actions occur:
   - overlays camera footage with border onto screen footage
   - given screen footage, camera footage, and border width and color create combined video
   - calculate camera delay using clap times in footage. assumes screen recording is longer than cam
   - calculate size of border for camera
   - create border as a solid color frame
   - scale camera down to given overlay-dims
   - overlay camera onto border frame
   - overlay bordered camera onto screen footage with calculated offsets"
  [{:keys [border overlay-dims camf scrf] :as props}]
  (let [{:keys [width color]} border
        [cw ch] (map #(+ (* 2 width) %) overlay-dims)
        [ow oh] (overlay-offsets (assoc props :fname scrf 
                                        :base-dims (get-resolution scrf)))
        delay (- (clap-time scrf) (clap-time camf))]
    (sh "ffmpeg"
        "-i" scrf
        "-i" camf
        "-f" "lavfi" 
        "-i" (str "color=" color ":s=" cw "x" ch)
        "-filter_complex"
        (str "[1:v]scale=" (apply str (interpose "x" overlay-dims)) "[scv];"
             "[2:v][scv]overlay=" width ":" width ":shortest=1[cam];"
             "[cam]setpts=PTS-STARTPTS+" delay "/TB[dcam];"
             "[0:v][dcam]overlay=" ow ":" oh ":shortest=1")
        "-c:a" "copy" "-y" "merged.mov")))

#+end_src

** fix-mono-audio
#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn fix-audio
  "Fixes issue where mono audio track plays only to the Left channel."
  [fname]
  (sh "ffmpeg" "-i" fname
      "-i" fname "-af" "pan=mono|c0=FL"
      "-c:v" "copy" "-map" "0:v:0" "-map" "1:a:0" "fixed-audio.mov"))

#+end_src

** nicer-vertical
Make vertical footage look better by scaling and blurring the footage to fill black bars.

- scale original clip up so that width is 1920, keep clip centered and crop height to 1080p
- apply gaussian blur
- scale original clip so height is 1080p
- overlay on blurred footage at center of clip

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn nicer-vertical
  [fname]
  (let [[name ext] (st/split "." fname)
        nfname (apply str [name "-nice" "." ext])]
    (sh "ffmpeg"
        "-i" fname
        "-filter_complex"
        (str "[0:v]scale=w=ih[sc1];"
             "[sc1]crop=h=1080[crop]"
             "[crop]gblur=steps=20[blur]"
             "[0:v]scale=h=iw[sc2];"
             "[blur][sc2]overlay=(main_w-overlay_w)/2:0:shortest=1")
        "-c:a" "copy" "-y" nfname)))
#+end_src

** cut-silence
Use this to get sequence of silence timestamps and durations. Then, try to cut and re-concat videos to elminate silence.

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
(defn get-sounds
  [fname]
  (->> (sh "ffmpeg" "-i" fname
           "-af" "silencedetect=n=-37dB:d=0.7"
           "-f" "null" "-")
       :err
       (st/split-lines)
       (map #(re-find #"silence_.+" %))
       (filter #(not (nil? %)))
       (map #(re-find #"\d+\.?(\d+)?" %))
       (map first)
       (map read-string)
       (rest)
       (partition 2)
       (map #(zipmap [:s :e] %))))

(defn clip-video
  [fname {:keys [s e]}]
  (let [dur (- e s)
        tmpf (str (st/replace (str s) "." "_")
                  "-" fname)]
    (sh "ffmpeg" "-i" fname 
        "-ss" (str s) "-t" (str dur)
        tmpf)))

(defn cut-merge
  [fname times]
  (let [fnames (map 
                #(str (st/replace (str (:s %)) "." "_")
                      "-" fname)
                times)]
    ;; create clips
    (doall (pmap #(clip-video fname %) times))
    ;; create clips file list
    (spit (str fname ".txt")
          (apply str (map #(str "file '" % "'\n") fnames)))
    ;; concat clips together
    (sh "ffmpeg" "-f" "concat" "-safe" "0"
        "-i" (str fname ".txt") "-c" "copy"
        (str "initial-cut" (get-extension fname)))
    ;; delete tmp files
    (mapv #(sh "rm" %) fnames)
    (sh "rm" (str fname ".txt"))))

#+end_src
** cli
Try out the first pipeline.

#+BEGIN_SRC clojure :tangle ./src/vidwiz.clj
#_(spit "props.edn" 
    {:screen
     {:fname "scr.mov"
      :left {:width 667 :offset 0}
      :right {:width 750 :offset 0}
      :gap 100
      :pos {:h :l :v :c}}

     :camera
     {:camf "cam.mov"
      :scrf "cropped-screen.mov"
      :border {:width 7 :color "cyan"}
      :overlay-dims [480 270]
      :gap 70
      :pos {:h :r :v :b}}})

(defn main
  "Main runs when vidwiz is run as a script.
  
  You can run this program with babashka:
   - chmod +x vidwiz.clj
   - ./vidwiz props.edn"
  []
  (let [fname (first *command-line-args*)
        props (when (= (get-extension fname) ".edn")
                (read-string (slurp fname)))]
    (when props
      #_(crop-pad-screen (:screen props))
      (pad-screen (:screen props))
      (overlay-camera  (:camera props))
      (fix-audio "merged.mov")
      (sh "cp" "fixed-audio.mov" "_precut.mov"))))

(main)

#+end_src
